
## google面试题--如何实现LRU，做到o(1)

### 概念
LRU（Least Recently Used）是指总是选择那个最长时间未被使用的被淘汰。

而LFU（Least Frequently Used）是访问次数最少的被淘汰。

### 分析
> 如何做到o(1)，就是在插入、淘汰和查找时时间复杂度都是o(1)。

插入和删除做到o(1)，想到双向链表方式保存元素间顺序关系，插入头部、删除尾部都可实现o(1)；查找做到o(1)，想到hashMap，保存元素，方便快速定位元素。

### 实现

```java

```



### LFU

#### 原理：LFU(Least Frequently Used)算法根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。

#### 实现: LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。
 
1. 新加入数据插入到队列尾部（因为引用计数为1）；
2. 队列中的数据被访问后，引用计数增加，队列重新排序；
3. 当需要淘汰数据时，将已经排序的列表最后的数据块删除。

#### 分析
      
命中率：一般情况下，LFU效率要优于LRU，且能够避免周期性或者偶发性的操作导致缓存命中率下降的问题。但LFU需要记录数据的历史访问记录，一旦数据访问模式改变，LFU需要更长时间来适用新的访问模式，即：LFU存在历史数据影响将来数据的“缓存污染”效用。
    
复杂度：需要维护一个队列记录所有数据的访问记录，每个数据都需要维护引用计数。
    
代价：需要记录所有数据的访问记录，内存消耗较高；需要基于引用计数排序，性能消耗较高。




### LRU

#### 原理：LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

#### 实现:
1. 新数据插入到链表头部；
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。

#### 分析
命中率:当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。

复杂度:实现简单。

代价:命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部

